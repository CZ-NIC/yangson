from .exceptions import EndOfInput as EndOfInput, InvalidArgument as InvalidArgument, ModuleNameMismatch as ModuleNameMismatch, ModuleRevisionMismatch as ModuleRevisionMismatch, StatementNotFound as StatementNotFound, UnexpectedInput as UnexpectedInput
from .parser import Parser as Parser
from .typealiases import YangIdentifier as YangIdentifier
from _typeshed import Incomplete
from typing import Optional

class Statement:
    prefix: Incomplete
    keyword: Incomplete
    argument: Incomplete
    superstmt: Incomplete
    substatements: Incomplete
    def __init__(self, kw: YangIdentifier, arg: Optional[str], pref: Optional[YangIdentifier] = None) -> None: ...
    def find1(self, kw: YangIdentifier, arg: Optional[str] = None, pref: Optional[YangIdentifier] = None, required: bool = False) -> Optional[Statement]: ...
    def find_all(self, kw: YangIdentifier, pref: Optional[YangIdentifier] = None) -> list['Statement']: ...
    def get_error_info(self) -> tuple[str | None, str | None]: ...

class ModuleParser(Parser):
    unescape_map: dict[str, str]
    name: Incomplete
    rev: Incomplete
    def __init__(self, text: str, name: Optional[YangIdentifier] = None, rev: Optional[str] = None) -> None: ...
    offset: Incomplete
    def parse(self) -> Statement: ...
    @classmethod
    def unescape(cls, text: str) -> str: ...
    def opt_separator(self) -> bool: ...
    def separator(self) -> None: ...
    def keyword(self) -> tuple[str | None, str]: ...
    def statement(self) -> Statement: ...
    def argument(self) -> bool: ...
    def sq_argument(self) -> str: ...
    def dq_argument(self) -> str: ...
    def unq_argument(self) -> str: ...
    def substatements(self) -> list[Statement]: ...
