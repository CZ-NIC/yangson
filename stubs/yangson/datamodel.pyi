import xml.etree.ElementTree as ET
from .enumerations import ContentType as ContentType
from .exceptions import BadYangLibraryData as BadYangLibraryData, InvalidArgument as InvalidArgument, NonexistentSchemaNode as NonexistentSchemaNode
from .instance import InstanceIdParser as InstanceIdParser, InstanceRoute as InstanceRoute, ResourceIdParser as ResourceIdParser, RootNode as RootNode
from .schemadata import SchemaContext as SchemaContext, SchemaData as SchemaData
from .schemanode import DataNode as DataNode, RawObject as RawObject, SchemaNode as SchemaNode, SchemaTreeNode as SchemaTreeNode
from .typealiases import DataPath as DataPath, PrefName as PrefName, SchemaPath as SchemaPath
from _typeshed import Incomplete
from typing import Optional

class DataModel:
    @classmethod
    def from_file(cls, name: str, mod_path: tuple[str] = ('.',), description: Optional[str] = None) -> DataModel: ...
    yang_library: Incomplete
    schema_data: Incomplete
    schema: Incomplete
    def __init__(self, yltxt: str, mod_path: tuple[str] = ('.',), description: Optional[str] = None) -> None: ...
    def module_set_id(self) -> str: ...
    def from_raw(self, robj: RawObject, subschema: Optional[PrefName] = None) -> RootNode: ...
    def from_xml(self, root: ET.Element, subschema: Optional[PrefName] = None) -> RootNode: ...
    def get_schema_node(self, path: SchemaPath) -> SchemaNode | None: ...
    def get_data_node(self, path: DataPath) -> DataNode | None: ...
    def ascii_tree(self, no_types: bool = False, val_count: bool = False) -> str: ...
    def clear_val_counters(self) -> None: ...
    def parse_instance_id(self, text: str) -> InstanceRoute: ...
    def parse_resource_id(self, text: str) -> InstanceRoute: ...
    def schema_digest(self) -> str: ...
